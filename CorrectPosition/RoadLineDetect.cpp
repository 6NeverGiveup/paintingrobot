#include "stdafx.h"
#include "RoadLineDetect.h"
////#include "PositionCorrect.h"
//#include <vector>
//using namespace HalconCpp;
//#define HEAD_RIGHT 90 ///////////////////////以右边车道为目标
//#define  HEIGHT 512
//#define  HALFWEIGHT 640*0.5
//#define RadioOFCircle  200
//
CRoadLineDetect::CRoadLineDetect(void)
{
	InitParmFirstCamera();
	InitParmSecondCamera();
}


CRoadLineDetect::~CRoadLineDetect(void)
{
	//CloseFramegrabber(hv_AcqHandle);
	
}

void CRoadLineDetect::InitParmFirstCamera()
{
	m_LocationCorrect.X_Correct=0;
	m_LocationCorrect.Y_Correct=0;
	m_ThresholdSlide.MinGreyThreshold=25;
	m_ThresholdSlide.MaxGreyThreshold=90;
	
	//Calibration 01: Code generated by Calibration 01
	//相机参数
	m_GreyThreshold[0]=0;
	m_GreyThreshold[1]=0;
	hv_CameraParameters.Clear();
	hv_CameraParameters[0] = 0.00621048;
	hv_CameraParameters[1] = -8710.04;
	hv_CameraParameters[2] = 3.74802e-006;
	hv_CameraParameters[3] = 3.75e-006;
	hv_CameraParameters[4] = 638.342;
	hv_CameraParameters[5] = 446.953;
	hv_CameraParameters[6] = 1288;
	hv_CameraParameters[7] = 964;
	hv_CameraPose.Clear();
	hv_CameraPose[0] = 0.176187;
	hv_CameraPose[1] = -0.0433811;
	hv_CameraPose[2] = 1.73491;
	hv_CameraPose[3] = 0.258499;
	hv_CameraPose[4] = 354.955;
	hv_CameraPose[5] = 359.402;
	hv_CameraPose[6] = 0;
	//赋值相机参数
	hv_Campar.Clear();
	hv_Campar[0] = 0.00621048;
	hv_Campar[1] = -8710.04;
	hv_Campar[2] = 3.74802e-006;
	hv_Campar[3] = 3.75e-006;
	hv_Campar[4] = 638.342;
	hv_Campar[5] = 446.953;
	hv_Campar[6] = 1288;
	hv_Campar[7] = 964;
	hv_OrnRow.Clear();
	hv_OrnRow[0] = 1288;
	hv_OrnRow[1] = 1288;
	hv_OrnRow[2] = 1288;
	hv_OrnColun.Clear();
	hv_OrnColun[0] = 964;
	hv_OrnColun[1] = 964;
	hv_OrnColun[2] = 964;
	//定义没有畸变的内参
	hv_CamparVirtualFixed = hv_Campar;
	hv_CamparVirtualFixed[1] = 0;
	//ImagePointsToWorldPlane(hv_CameraParameters, hv_CameraPose, 512, 320, "mm", &hv_CenterXCoord, &hv_CenterYCoord);
	/*Lline=Rline=DLline=DRline=SLline=SRline=false;*/
}
void CRoadLineDetect::InitParmSecondCamera()
{
	m_LocationCorrectTwo.X_Correct=0;
	m_LocationCorrectTwo.Y_Correct=0;
	
	//Calibration 01: Code generated by Calibration 01
	//相机参数
	m_ThresholdSlideTwo.MinGreyThreshold=25;
	m_ThresholdSlideTwo.MaxGreyThreshold=90;
	hv_CameraParametersTwo.Clear();
	hv_CameraParametersTwo[0] = 0.00621048;
	hv_CameraParametersTwo[1] = -8710.04;
	hv_CameraParametersTwo[2] = 3.74802e-006;
	hv_CameraParametersTwo[3] = 3.75e-006;
	hv_CameraParametersTwo[4] = 638.342;
	hv_CameraParametersTwo[5] = 446.953;
	hv_CameraParametersTwo[6] = 1288;
	hv_CameraParametersTwo[7] = 964;
	hv_CameraPoseTwo.Clear();
	hv_CameraPoseTwo[0] = 0.176187;
	hv_CameraPoseTwo[1] = -0.0433811;
	hv_CameraPoseTwo[2] = 1.73491;
	hv_CameraPoseTwo[3] = 0.258499;
	hv_CameraPoseTwo[4] = 354.955;
	hv_CameraPoseTwo[5] = 359.402;
	hv_CameraPoseTwo[6] = 0;
	//赋值相机参数
	hv_CamparTwo.Clear();
	hv_CamparTwo[0] = 0.00518258;
	hv_CamparTwo[1] = -818.288;
	hv_CamparTwo[2] = 3.75082e-006;
	hv_CamparTwo[3] = 3.75e-006;
	hv_CamparTwo[4] = 652.013;
	hv_CamparTwo[5] = 481.973;
	hv_CamparTwo[6] = 1288;
	hv_CamparTwo[7] = 964;
	hv_OrnRowTwo.Clear();
	hv_OrnRowTwo[0] = 1288;
	hv_OrnRowTwo[1] = 1288;
	hv_OrnRowTwo[2] = 1288;
	hv_OrnColunTwo.Clear();
	hv_OrnColunTwo[0] = 964;
	hv_OrnColunTwo[1] = 964;
	hv_OrnColunTwo[2] = 964;
	//定义没有畸变的内参
	hv_CamparVirtualFixedTwo = hv_CamparTwo;
	hv_CamparVirtualFixedTwo[1] = 0;
}
void CRoadLineDetect::InitHalconRecPointGrey(void)
{
	//Image Acquisition 01: Code generated by Image Acquisition 01
	OpenFramegrabber("GigEVision", 0, 0, 0, 0, 0, 0, "default", -1, "default", -1,"false", "default", 
		                   "00b09dd93696_PointGreyResearch_BlackflyBFLYPGE1", 0, -1, &hv_AcqHandle);
	SetFramegrabberParam(hv_AcqHandle, "BalanceWhiteAuto", "Continuous");
	GrabImageStart(hv_AcqHandle, -1);
}
void CRoadLineDetect::TranstheImagetoWord(HTuple Row,HTuple Column)
{
	//ImagePointsToWorldPlane(hv_CameraParameters, hv_CameraPose, Row, Column, "mm", &hv_XCoord, &hv_YCoord);
}

LocationCorrect CRoadLineDetect::RoadRec(unsigned char* pImgData, long lWidth, long lHeight)
{ 
	HObject  ho_RegionFillUp, ho_SelectedRegions, ho_ActualImage,ho_SelectedRegionsRec; 
	hv_AnswerLengthTwo=0;
	GenImageInterleaved (&ho_ActualImage, (Hlong)pImgData, "bgr", lWidth, lHeight,  -1, "byte", 0, 0, 0, 0, -1, 0);
	DispObj(ho_ActualImage,hv_WindowHandle);
	Rgb1ToGray(ho_ActualImage, &ho_GrayImage);
	//生成径向畸变映射图
	GenRadialDistortionMap(&ho_MapFixed, hv_Campar, hv_CamparVirtualFixed, "bilinear");
	//利用映射图获得消除畸变后的图像
	MapImage(ho_GrayImage, ho_MapFixed, &ho_ImageMapped);
	//设置显示图片的颜色和线宽


	//选取合适的区域
	GetImageSize(ho_ImageMapped, &hv_Width, &hv_Height);
	Rectangle1Domain(ho_ImageMapped, &ho_ImageReduced, 0, 0, hv_Width, hv_Height);

	//使用灰度直方图并进行膨胀腐蚀处理
	Threshold(ho_ImageMapped, &ho_Regions, m_ThresholdSlide.MinGreyThreshold,m_ThresholdSlide.MaxGreyThreshold);
	ErosionCircle(ho_Regions, &ho_RegionErosion, 3.5);
	ErosionCircle(ho_RegionErosion, &ho_RegionErosion1, 3.5);
	DilationCircle(ho_RegionErosion1, &ho_RegionDilation, 5);
	DilationCircle(ho_RegionDilation, &ho_RegionDilation1, 10);
	//联通区域并筛选出所需要的部分
	Connection(ho_RegionDilation1, &ho_ConnectedRegions);
	AreaCenter(ho_ConnectedRegions, &hv_Area, &hv_Row, &hv_Column);
	Contlength(ho_ConnectedRegions, &hv_ContLength);
	SelectShape(ho_ConnectedRegions, &ho_SelectedRegions1, "area", "and", 15000, 100000);
	SelectShape(ho_SelectedRegions1, &ho_SelectedRegions2, "contlength", "and", 600,1500);
	AreaCenter(ho_SelectedRegions2, &hv_Area1, &hv_Row1, &hv_Column1);
	TupleLength(hv_Area1, &hv_AnswerLength);
	if (0 != (hv_AnswerLength==1))
	{
		SetColor(hv_WindowHandle,"red");
		SetLineWidth(hv_WindowHandle,5);
		DispCross(hv_WindowHandle, hv_Row1, hv_Column1, 200, 0);
		m_LocationCorrect.X_Correct=(FIRSTCAMERAXAXISWIDTH /2-hv_Column1.D())*FIRSTEVERYPIXELTOEVERYCENTIMETREX;   
		m_LocationCorrect.Y_Correct=(FIRSTCAMERAYAXISHEIGHT/2-hv_Row1.D())*FIRSTEVERYPIXELTOEVERYCENTIMETREY;
		m_LocationCorrect.dignose=true;
	}
	else
	{
		m_LocationCorrect.X_Correct=0.0;
		m_LocationCorrect.Y_Correct=0.0;
		m_LocationCorrect.dignose=false;
	}
	return m_LocationCorrect;
	
}
	
LocationCorrect CRoadLineDetect::RoadRecTwo(unsigned char* pImgDataTwo, long lWidthTwo, long lHeightTwo)
{ 
	HObject  ho_RegionFillUpTwo, ho_SelectedRegionsTwo, ho_ActualImageTwo,ho_SelectedRegionsRecTwo; 
	GenImageInterleaved (&ho_ActualImageTwo, (Hlong)pImgDataTwo, "bgr", lWidthTwo, lHeightTwo,  -1, "byte", 0, 0, 0, 0, -1, 0);
	DispObj(ho_ActualImageTwo,hv_WindowHandleTwo);
	Rgb1ToGray(ho_ActualImageTwo, &ho_GrayImageTwo);
	//生成径向畸变映射图
	GenRadialDistortionMap(&ho_MapFixedTwo, hv_CamparTwo, hv_CamparVirtualFixedTwo, "bilinear");
	//利用映射图获得消除畸变后的图像
	MapImage(ho_GrayImageTwo, ho_MapFixedTwo, &ho_ImageMappedTwo);
	//设置显示图片的颜色和线宽
	//if (HDevWindowStack::IsOpen())
		//SetColor(HDevWindowStack::GetActive(),"red");
	//if (HDevWindowStack::IsOpen())
		//SetLineWidth(HDevWindowStack::GetActive(),10);

	//选取合适的区域
	GetImageSize(ho_ImageMappedTwo, &hv_WidthTwo, &hv_HeightTwo);
	Rectangle1Domain(ho_ImageMappedTwo, &ho_ImageReducedTwo, 0, 0, hv_WidthTwo, hv_HeightTwo);

	//使用灰度直方图并进行膨胀腐蚀处理
	Threshold(ho_ImageMappedTwo, &ho_RegionsTwo, m_ThresholdSlideTwo.MinGreyThreshold, m_ThresholdSlideTwo.MaxGreyThreshold);
	ErosionCircle(ho_RegionsTwo, &ho_RegionErosionTwo, 3.5);
	ErosionCircle(ho_RegionErosionTwo, &ho_RegionErosion1Two, 3.5);
	DilationCircle(ho_RegionErosion1Two, &ho_RegionDilationTwo, 5);
	DilationCircle(ho_RegionDilationTwo, &ho_RegionDilation1Two, 10);
	//联通区域并筛选出所需要的部分
	Connection(ho_RegionDilation1Two, &ho_ConnectedRegionsTwo);
	AreaCenter(ho_ConnectedRegionsTwo, &hv_AreaTwo, &hv_RowTwo, &hv_ColumnTwo);
	Contlength(ho_ConnectedRegionsTwo, &hv_ContLengthTwo);
	SelectShape(ho_ConnectedRegionsTwo, &ho_SelectedRegions1Two, "area", "and", 15000, 100000);
	SelectShape(ho_SelectedRegions1Two, &ho_SelectedRegions2Two, "contlength", "and", 600, 
		1500);
	AreaCenter(ho_SelectedRegions2Two, &hv_Area1Two, &hv_Row1Two, &hv_Column1Two);

	TupleLength(hv_Area1Two, &hv_AnswerLengthTwo);
	if (0 != (hv_AnswerLengthTwo==1))
	{
		SetColor(hv_WindowHandleTwo,"red");
		SetLineWidth(hv_WindowHandleTwo,5);
		DispCross(hv_WindowHandleTwo, hv_Row1Two, hv_Column1Two, 200, 0);
		m_LocationCorrectTwo.X_Correct=(SECONDCAMERAXAXISWIDTH /2-hv_Column1Two.D())*SECONDEVERYPIXELTOEVERYCENTIMETREX;
		m_LocationCorrectTwo.Y_Correct=(SECONDCAMERAYAXISHEIGHT/2-hv_Row1Two.D())*SECONDEVERYPIXELTOEVERYCENTIMETREY;
		m_LocationCorrectTwo.dignose=true;
	}
	else
	{
		m_LocationCorrectTwo.X_Correct=0.0;
		m_LocationCorrectTwo.Y_Correct=0.0;
		m_LocationCorrectTwo.dignose=false;
	}
	
	//由上，得到平均偏移角度，相机镜头修正方向为顺时针旋转
	return m_LocationCorrectTwo;
}	

bool CRoadLineDetect::InitHalconDisp(Hlong FatherWndID,CRect RecOfWindowDispLay )
{
	HTuple uPLeftCol=0;
	HTuple uPLeftRow=0;
	HTuple uPRightCol=1288;
	HTuple uPRightRow=964;
	OpenWindow(RecOfWindowDispLay.top,RecOfWindowDispLay.left,RecOfWindowDispLay.Width(),RecOfWindowDispLay.Height(), FatherWndID,"","",&hv_WindowHandle);
	HDevWindowStack::Push(hv_WindowHandle);
	SetPart(hv_WindowHandle,uPLeftRow,uPLeftCol, uPRightRow, uPRightCol);
	return false;
}
bool CRoadLineDetect::InitHalconDispTwo(Hlong FatherWndID,CRect RecOfWindowDispLay)
{
	HTuple uPLeftCol=0;
	HTuple uPLeftRow=0;
	HTuple uPRightCol=1288;
	HTuple uPRightRow=964;
	OpenWindow(RecOfWindowDispLay.top,RecOfWindowDispLay.left,RecOfWindowDispLay.Width(),RecOfWindowDispLay.Height(), FatherWndID,"","",&hv_WindowHandleTwo);
	HDevWindowStack::Push(hv_WindowHandleTwo);
	SetPart(hv_WindowHandleTwo,uPLeftRow,uPLeftCol, uPRightRow, uPRightCol);
	return false;
}
bool CRoadLineDetect::GrabPictrueFromPointGrey(void)
{
	GrabImageAsync(&ho_Image, hv_AcqHandle, -1);
	return true;
}
bool CRoadLineDetect::ChoseCloseCameraThread()
{
	return true;
}
void CRoadLineDetect::SetThresholdSlider(ThresholdSlide m_ThresholsSlider)
{
	m_ThresholdSlide=m_ThresholsSlider;
}
void CRoadLineDetect::SetThresholdSliderTwo(ThresholdSlide m_ThresholsSlider)
{
	m_ThresholdSlideTwo=m_ThresholsSlider;
}