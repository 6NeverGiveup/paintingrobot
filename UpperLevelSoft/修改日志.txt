11:14 2017/8/14
由于对每把枪要增加延迟或提前的开关点，在新的结果翻译函数中增加了相应内容
思想：
对所有原始突变点，逐一按照所有喷枪的提前开关量进行变化、扩充，会导致每个突变点变成八个扩充后的突变点（4把枪）
针对每一个原始突变点：
由于扩充后各个突变点，各把喷枪的状态不同，且可能冲突，因此需要首先把扩充后的所有突变点排序(由小到大，只考虑了正向移动)，
然后由前一原始突变点的喷枪开关状态，当前原始突变点应该的喷枪状态。结合后逐枪判断每个扩充后突变点处的喷枪状态值。再记录。

对所有原始突变点扩充，并逐个原始突变点排序、记录了喷枪状态后，再次排序，记录状态。

问题：
1.然而用map会自动把重复的突变点去掉，导致少设置喷枪状态，并报错。解决办法，单独把重复的突变点找出来特殊处理，写了函数
目前发觉直接用vector代替map可能更简洁
2.没考虑逆向移动问题
3.在最后对所有扩充后的突变点排序，记录喷枪状态。没有考虑如果2号原始突变点扩充的新突变点影响了1号原始突变点扩充出的新突变点的喷枪状态咋办。可能存在bug
4.可能有地方限定了喷枪为4把，如果喷枪数超过可能存在bug
5.需要将高级设置里设置的参数保存到文本文件中，每次开启新程序可以自动保存、读取，而不是每次都需要设置，原程序中的保存方式应该修改。应增加配置文件保存功能
6.在数据传输完成后应该给文字提示显示完成
7.多色喷枪未修改程序考虑延迟

18:48 2017/8/14
问题：
1. 上次的问题3已确认存在
2. 起始点处的问题。在第一个点处，如-3.4的y坐标处由于1号喷枪提前关闭导致应该状态为0，而0号喷枪在坐标0处应该开启导致状态为1，如果强行将负坐标抹去，两种情况就会矛盾，尤其负坐标抹去后，后面由于都是0的位置，在最后排序时会把重复点再次去掉。又会导致问题

23:58 2017/8/14
原来对每一个原始突变点进行扩充后，将开启延迟和关闭延迟的突变点分别处理，并且始终以上一个原始突变点处的所有喷枪状态为基础。现在发觉必须将开启、关闭延迟导致的突变点统一进行排序，统一进行处理，并且上一喷枪状态ＰｒｅＣｏｌｏｒ不能再分开处理，观察发现这会导致问题。
原来在SetExpandedCheckPointsForEachGun函数中，对当前是要判断开启还是要判断关闭进行了区别。现在还是不区别为好，因为会出问题，而且同一把喷枪，在同一个原始突变点造成的扩充点范围内，要么提前开要么提前关，要么维持原状，不可能同时满足这几种情况，所以不会矛盾。

1:19 2017/8/15
问题：
1.发现bug 当不设置高级设置，直接点击时，到CheckEveryGunDelayAndAddCheckPoint函数调用时出错，原因是突变点有12个，而颜色状态只有11个，他俩必须严格对应。原因不明。
经查明，是吴学易所写的TranslateEveryChangePoint函数中最后一个循环，当第一把喷枪走完所有色块后的处理部分有问题

10:11 2017/8/15
1. 宏#define clrbit(x,y) x&=！(1<<y) //将X的第Y位清0  有问题，不能用!取反，改为位反~
2. 修改了扩充后突变点的处理方式，将所有突变点不管开启关闭统一放到一个map里处理，在具体处理时分别按照是开是关，都各处理一边

12:40 2017/8/15
1.正向移动目前测试可用
2. 增加了对颜色状态数与突变点数个数的一致性判断，如果两者数量不一致，将不会写入DownPlcAndMotion文件，直接跳出，也不会报错！！！！
问题：
2. 1:19 2017/8/15 问题1. 经联系发现是吴学易修改了原始的颜色计算函数(据说在末尾部分特殊处理有bug)，吴学易所写的TranslateEveryChangePoint函数只能用于喷枪间距小于单元格大小的情况。
8.15已解决


14:21 2017/8/15
1. 重写了对突变点的翻译函数TranslateEveryChangePoint2，目前坐标点正常，在列末尾扩充色块预计算需要多少个突变点
2. 将原来我写的颜色计算函数覆盖了回去，当枪距设为60时，计算的颜色貌似不对

问题：
逆向移动问题未解决

18:41 2017/8/15
1. CheckGunStatus内if (NumOfValidCell<=IndexOfCurCell)       //这个喷枪在有颜色的有效范围内,IndexOfCurCell代表在列中单元的序号，逆序时要不要换成大于号？
存疑，
不需要
2. 对CheckGunStatus，CheckStatusInRowOfParmVec函数进行了梳理和修改，发现若干bug，增加了注释

3:15 2017/8/16

1. 对CheckGunStatus，CheckStatusInRowOfParmVec函数进行了梳理和修改，发现若干bug，调试不通，干脆废弃CheckStatusInRowOfParmVec函数了进行了重写，通过对结尾部分扩充虚拟色块，再预计算出一列需要增加的突变点数作为限制条件，计算所有颜色状态结果成功
修改了CheckGunStatus，但该函数内含原来的计算模式，所以不好理解。

9:04 2017/8/16
1. 修改了预计算出一列需要增加的突变点数作为限制条件的公式。目前成功，需要在各种状态反复测试
2. 软件的防呆提醒太差

问题：
逆向移动问题未解决

16:44 2017/8/16
1.修正了CheckStatusInRowOfParmVec_fix函数中的bug
2.在CheckEveryGunDelayAndAddCheckPoint函数中最后增加了对源自不同原始突变点的扩充点如果相重合时的处理

问题：
源自不同原始突变点的扩充点，如果后一个的跑到前面某个突变点的前面去了，这时太复杂，还未处理

17:32 2017/8/16
修正了点集选取但不选，再选出错的bug

9:17 2017/8/18
增加延迟突变点间相互冲突，即后一个原始突变点产生的延迟突变点，跑到前某个原始突变点延迟扩充后的范围内的情况。处理思路是，找到这个产生冲突的突变点，把这个突变点是由几号喷枪的延时造成的，把这几号喷枪对应的颜色位的值取出来，再把最新的这几位的值覆盖回去所有与之冲突的突变点对应的颜色位

调试过程中，把一些行代码注释了，可能恢复的时候漏掉了，所以需要判断

问题：
1. 先高级设置，再选取图片，会导致错误结果

12:08 2017/8/19
修正了冲突处理中，BackSetConflictPointColor，CheckConflictFromDifferentOriginCheckPoint，CoverGivenBitColorForGivenPoint函数中的bug，不再出现某把喷枪只打开一瞬的情况

10:57 2017/8/21
修正了冲突处理中的逻辑错误

问题：
重合点的判断与处理还有问题，可能存在微小差别的重合点，且两者并非在排序后紧密相邻的情况，会导致多出一些不必要的点，目前暂不解决。

13:45 2017/8/21
1.增加逆序运动的处理，可以实现多列喷涂了，监测运作正常，还需进一步验证
2.增加了对扩展点的限制处理，上限为运动范围上限MaxRange,下限为0。

23:08 2017/8/21
修改JudgeExpandedCheckPointType函数中的bug，原来比较给定的点的坐标和所属的类型突变点集中所有点的坐标。坐标相同就认为它属于这种类型。
例如枪0提前关导致的0点突变点，就不应该属于开启类型的突变点。修改为必须*itAllDelayedCheckSets==*itSorteTypeCheckSets，即必须完全一致才行。

问题：
1.发现当重复设置了高级设置后，点识别，图片没了。再读入图片也不行
0:13 2017/8/22
解决重合点的判断与处理问题，解决可能存在微小差别的重合点问题，解决两者并非在排序后紧密相邻的情况，改为在所有已排序的点中把所有重合的点，都用新的状态覆盖它。

问题：
1. 坐标为20突变点的状态应为1，-23.4的1号喷枪提前开量，导致突变点坐标变为0，而0突变点本来是颜色0，这就导致会在寻重合点时将坐标0的颜色状态更新为1.
原因：
    1.现在扩充突变点后，将扩充突变点处的颜色设制的方法为：依据前一颜色状态Precolor按照本突变点的意义，置位或清零相应喷枪位
    2.现在处理突变点冲突的思路是，对当前突变点，把所有与之发生冲突的突变点的状态的相应喷枪位，进行置位或清零操作。
例如0突变点的状态应为1，但因为0喷枪延时20开启，导致0的状态为0，而20的状态才是1。下面如果20原始突变点，扩充后产生一个0位的突变点，计算颜色状态时，以上一个原始突变点也就是0原始突变点的状态为PreColor就会出错。

17:40 2017/8/22
1.修改了CheckOneCheckPoint函数中关于此前颜色状态Precolor的设置，原来直接那前一原始突变点处的颜色状态作为Precolor。现在增加findPreColorAfterPreExpand函数对每一个扩充后的突变点均搜索最接近他的前一突变点处的颜色状态作为Precolor

问题：
1. 存在逻辑上的问题。当原始100，因喷枪2扩充为120时，应该为0.但120突变点的Precolor来自最近的112。112的喷枪0位为1，开，原因是它来自与90的突变点处扩充而来。而在该初，喷枪0位确实为1。

15:55 2017/8/23
1.反复比较了计算Precolor的两种方式，以前一个原始突变点为确实都有bug。现在还是设置findPreColorAfterPreExpand函数的方式计算更为合适。但将修改模式，SetExpandedCheckPointsForEachGun在设置完给定的枪位之后，增加CheckAndSetRemainColor函数对所有向后方扩充的扩充突变点按照新突变点所在的位置查找相应的原始突变点状态设置其他喷枪状态，而不是单纯保持原状。CheckAndSetRemainColor会查找新位置的前一原始突变点与后一原始突变点。这会减轻bug，但仍然还会有bug。对向前方扩充的不做处理，因为向前扩充的，它的状态影响已经由findPreColorAfterPreExpand函数考虑过了。

0:34 2017/8/24
修改了整体的扩充框架。改为方案2：
先排序，在排好序后，调用原来的若干函数，逐个排序后的突变点进行颜色设置。结果发现仍然存在冲突，而且更加严重，难以查找冲突。所以停止使用方案2.改回方案1，修改bug

10:28 2017/8/25
目前方案1的问题是，应该延时关闭的没有延时关闭。比如喷枪应该在200+60+40处延时关闭。但结果在277处就关闭了。原因在于在200+60的延时原始突变点处，按照-23的延时产生了喷枪1的延时开启点。在该点处的Precolor为272处的颜色，而该处来自200+62+12扩充而得，就该颜色位0。虽然最终在冲突消解函数中把272该位改为了开
272位其实设置了颜色位开，但是在后增加的CheckAndSetRemainColor处又关了。在因为272处，CheckAndSetRemainColor函数查出的前一原始突变点为当前的原始突变200+60点，状态为0,即便在延时关范围内，但是还是会维持为0

修正：CheckAndSetRemainColor中如果前一状态是当前，则以PreColor作为前一状态

修正2：CheckAndSetRemainColor中无用循环减少了

13:59 2017/9/1
放弃方案1及方案2。采用方案3调试成功，应该没有大的逻辑问题了
方案内容：
1.首先把所有的扩充后突变点找到、排序生成序列。
2.对每把喷枪，从原始突变点处开始再算一遍，找到没把喷枪该发生状态变化的突变点，也就必然是开、关一对一对的突变点。并记录这些突变点处的颜色状态（只含一把喷枪的状态），形成一个以喷枪号为行，每个突变点为列的二维vector数组m_vStackOfAllDelayPointIndexByGun，以及颜色二维数组m_vStackOfAllColorsIndexByGun
3.回过头，依据m_vStackOfAllDelayPointIndexByGun中的喷枪开关点，在排好序的扩充突变点集m_CheckPointListWithDelay中。找到每一个喷枪开关点对应的位置。
并在m_CheckPointColorListWithDelay中，把所有喷枪的颜色逐一写入。形成最终的各扩充后突变点的颜色序列

问题：
1 耗时过长。但逻辑上完备。
2 另外需要把状态重复的突变点全部删除，减少突变点数目
3 很多子函数为了与原来方案1兼容，保留了很多无用操作。无用变量，需要削减
4.逆序行动时的状态还需要验证。未经仔细验证

11:05 2017/9/6
1.程序验证成功
2.增加了对结果内的重复状态突变点的删除ShrinkCheckPointVec函数，还需验证。貌似会导致列与列之间的移动不再是平移，而是斜向移动，分析这应该合理。因为前一列后面可能都是状态0，全部删除状态重复点了，不用再跑。而下一列，可能又必须从列尾开始逆向移动，因此会导致斜向移动，不确定是否会与下位机程序冲突。需要验证

10:56 2017/12/19
1.修正了Pmac文件中#include <>带来的无法使用相对路径必须必须包含绝对路径的问题
2. Parm中增加了定义默认喷枪数的宏，目前只在DownParmValue中用到
3.增加了CDownParmAdjust类，专门用来处理数据的额外处理平移操作，之前做的其他额外操作后续可以移到此类中，以便模块化。该类实现两个步骤1）所有喷涂动作向下平移DEFAULT_TRANSIT_VALUE，2）偶数列向Y轴正方向再移动EXTRA_TRANSIT_FOR_EVEN_ROW，这些宏在Parm.h中定义，特别注意，移动后的运动范围
4.把DownParmValue类中定义的一些类型移到DownParmValueHead头文件

不确定是否还需要专门去调整运动控制卡的运动起止参数，因为整个平移后这些参数需要做修改，在已修改部分未涉及，有待确认。如果新的下位机仅依靠突变点坐标就可以那么久无需再做修改

0:22 2017/12/28。
1.增加了当换列时，平移的函数，避免直接走斜线。解决方案是，在下一列的头上插入一个无色单元，该单元的纵坐标与前一单元的纵坐标相同
2.发现当出现阶梯状图案时，有时会不写入。报错的bug。经调试发现是输入计算的原始突变点的数目与颜色数目不相同，导致后续的延迟突变点计算函数直接退出。
调试中增加了UpperSoftWare界面函数处一个错误对话框。
  发现是ResultAdapter文件中的CheckCurRowIfInsertNullColor_FixBlankRow函数带来的问题。该函数本身就为了避免走斜线，插补了一个空白方格，导致颜色的数目增加。而运动范围参数与突变点的个数都与之不匹配。这是bug
解决中....
注意，这里假设列号与运动其实终止位置不会完全相同。否则会ExtendMotionRangeForInsertedNullCell()出错！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！

3.加了一些注释

2:26 2017/12/29
1. 对CResultAdapter进行了修改，额外增加了一套对插补后的运动范围进行扩充的函数，接口函数为ExtendMotionRangeForInsertedNullCell()，该函数必须在PLC及运动控制卡数据形成后再调用，解决运动参数与颜色状态不匹配问题
2. 发现bug当出现斜坡型色块堆积的时，容易出现问题，已解决是TranslateEveryChangePoint2函数中的问题
3.修改了界面对话框类中DownLoadPlcParm，DownLoadPlcParm，OnBnClickedDownParm()函数，修改了他们的调用方式

22:40 2018/1/27
调整：
1）奇数列
1号枪延迟开20mm，延迟关20mm（第一列第一格除外）；
2号枪延迟开20mm，关枪位置准确；
3号枪延迟开20mm，延迟关20mm；
4号枪延迟开20mm，延迟关20mm（图中未示意）。
2）偶数列
4号枪提前关20mm。
解决：
增加逆序的延迟设置部分，在程序中单独处理，将逆序的延迟另设

11:42 2018/2/3
1. 解决逆序运动问题，在界面中增加了逆序运动时喷枪延迟参数的设置对话框，再把所有参数传给程序内部。DownValue 类中修改了StartOpenPlc函数，在其中把逆序的延迟参数m_fRevGunDelay也传进去，并在调用CalculateAllDelayedCheckPointInRow函数时，视正向还是逆向运动使用不同的参数传进去。
初步测试可用。

问题：
1.提出来的问题中对第一列第一格，特殊处理，不对第一把喷枪的延迟做任何处理。这个比较麻烦，暂时不动。看效果是否可以接受。
2.界面调整未准确去做，需要精细调一下


